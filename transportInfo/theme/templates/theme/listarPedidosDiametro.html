{% extends 'theme/base.html' %}

{% block title %}Pedidos por Diâmetro{% endblock %}

{% block content %}
<h1 class="text-3xl font-bold text-white mb-8">Pedidos por Diâmetro</h1>

<!-- Barra de Pesquisa -->
<div class="mb-4">
    <input type="text" id="searchInput" placeholder="Pesquisar pedidos..."
           class="w-full md:w-1/2 px-4 py-2 border rounded shadow focus:outline-none focus:ring focus:ring-blue-300" />
</div>

<!-- Tabela -->
<div class="overflow-x-auto w-full max-w-6xl bg-white rounded-lg shadow-lg p-6">
    <table class="min-w-full table-auto text-xs md:text-sm text-left" id="pedidoTable">
        <thead class="bg-blue-600 text-white uppercase font-semibold text-sm">
            <tr>
                <th class="px-4 py-3">ID</th>
                <th class="px-4 py-3">QR Code</th>
                <th class="px-4 py-3">Diâmetro</th>
                <th class="px-4 py-3">Num. serie das fieiras</th>
                <th class="px-4 py-3">Nº de Fieiras</th>
                <th class="px-4 py-3">Pedido Por</th>
                <th class="px-4 py-3">Data de Criação</th>
                <th class="px-4 py-3">Feito</th>

            </tr>
        </thead>
        <tbody class="text-gray-800">
            {% for pedido in pedidos %}
            <tr class="border-b hover:bg-gray-100 transition-colors">
                <td class="px-4 py-2">{{ pedido.id }}</td>
                <td class="px-4 py-2">{{ pedido.qr_code }}</td>
                <td class="px-4 py-2">{{ pedido.diametro }}</td>
                <td class="px-4 py-2">{{ pedido.serie_dies }}</td>
                <td class="px-4 py-2">{{ pedido.numero_fieiras }}</td>
                <td class="px-4 py-2">{{ pedido.pedido_por }}</td>
                <td class="px-4 py-2">{{ pedido.created_at|date:"d/m/Y H:i" }}</td>
                <td class="px-4 py-2 text-center">
                    <label class="inline-flex items-center gap-2">
                        <input
                        type="checkbox"
                        class="h-4 w-4 accent-green-600 js-toggle-feito"
                        data-url="{% url 'toggle_pedido_diametro_feito_ajax' pedido.id %}"
                        {% if pedido.checkbox %}checked{% endif %}
                        />
                        <span class="text-sm text-gray-700 js-toggle-label">
                        {% if pedido.checkbox %}Sim{% else %}Não{% endif %}
                        </span>
                    </label>
                </td>
            </tr>
            {% empty %}
            <tr>
                <td colspan="6" class="text-center text-gray-500 py-4">Nenhum pedido encontrado.</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<!-- Script de filtro -->
<script>

     // Lê o csrftoken do cookie (padrão Django)
    function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
    }
    const csrftoken = getCookie('csrftoken');

    function setDisabled(el, disabled) {
        el.disabled = disabled;
        if (disabled) el.classList.add('opacity-60', 'cursor-not-allowed');
        else el.classList.remove('opacity-60', 'cursor-not-allowed');
    }

    // Delegação: escuta mudanças em qualquer checkbox com a classe .js-toggle-feito
    document.addEventListener('change', async (e) => {
        const input = e.target.closest('.js-toggle-feito');
        if (!input) return;

        const url = input.getAttribute('data-url');
        if (!url) return;

        const label = input.closest('label')?.querySelector('.js-toggle-label');
        const prevChecked = !input.checked ? true : false; // valor anterior caso precise reverter
        // (na verdade, prevChecked deve ser o inverso do estado atual)
        const previous = !input.checked;

        setDisabled(input, true);

        try {
        const resp = await fetch(url, {
            method: 'POST',
            headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({ checked: input.checked })
        });

        if (!resp.ok) throw new Error('Erro na resposta do servidor');

        const data = await resp.json();
        if (!data.ok) throw new Error('Resposta JSON sem ok=true');

        if (label) label.textContent = data.label || (data.checked ? 'Sim' : 'Não');
        } catch (err) {
        // Reverte estado se falhar
        input.checked = previous;
        if (label) label.textContent = previous ? 'Sim' : 'Não';
        console.error(err);
        // feedback rápido (opcional substituir por toast)
        alert('Não foi possível atualizar. Tenta novamente.');
        } finally {
        setDisabled(input, false);
        }
    });
    
    document.addEventListener('DOMContentLoaded', function () {
        const searchInput = document.getElementById('searchInput');
        const tableBody = document.getElementById('pedidoTable').getElementsByTagName('tbody')[0];

        searchInput.addEventListener('keyup', function () {
            const filter = searchInput.value.toLowerCase();
            const rows = tableBody.getElementsByTagName('tr');

            for (let i = 0; i < rows.length; i++) {
                const cells = rows[i].getElementsByTagName('td');
                let found = false;

                for (let j = 0; j < cells.length; j++) {
                    if (cells[j].textContent.toLowerCase().includes(filter)) {
                        found = true;
                        break;
                    }
                }
                rows[i].style.display = found ? '' : 'none';
            }
        });
    });

</script>
{% endblock %}
